// Package testlg contains a lg.Log implementation that
// directs output to a testing.T.
//
// This is useful if your code under test writes to a log,
// and you want to capture that log output under testing.T.
// For example:
//
//  func TestMe(t *testing.T) {
//    log := testlg.New(t)
//    log.Debugf("Hello world")
//    log.Warnf("Hello Mars")
//    log.Errorf("Hello Venus")
//  }
//
// produces the following:
//
//  === RUN   TestMe
//  --- PASS: TestMe (0.00s)
//      testlg_test.go:64: 09:48:38.849066 	DEBUG	Hello World
//      testlg_test.go:65: 09:48:38.849215 	WARN 	Hello Mars
//      testlg_test.go:66: 09:48:38.849304 	ERROR	Hello Venus
//
// Log has a "strict" mode which pipes Errorf output to t.Error
// instead of t.Log, resulting in test failure. This:
//
//  func TestMe(t *testing.T) {
//    log := testlg.New(t).Strict(true)
//    log.Debugf("Hello World")
//    log.Warnf("Hello Mars")
//    log.Errorf("Hello Venus") // pipes to t.Error, resulting in test failure
//  }
//
// produces:
//
//  === RUN   TestMe
//  --- FAIL: TestMe (0.00s)
//      testlg_test.go:64: 09:52:28.706482 	DEBUG	Hello World
//      testlg_test.go:65: 09:52:28.706591 	WARN 	Hello Mars
//      testlg_test.go:66: 09:52:28.706599 	ERROR	Hello Venus
//
// This Log type does not itself generate log messages: this is
// delegated to a backing log impl (loglg by default).
// An alternative impl can be set by passing a log factory func
// to NewWith, or by changing the testlg.FactoryFn package variable.
package testlg

import (
	"bytes"
	"io"
	"io/ioutil"
	"strings"
	"sync"
	"testing"

	"github.com/neilotoole/lg"
	"github.com/neilotoole/lg/loglg"
)

// FactoryFn is used by New to create the backing Log impl.
// By default this func uses stdlib log, but other impls
// can be used as follows:
//
//  // Use zap as the log implementation.
//  testlg.FactoryFn = func(w io.Writer) lg.Log {
//    return zaplg.New(w, "text", true, 1)
//  }
var FactoryFn = func(w io.Writer) lg.Log {
	return loglg.NewWith(w, true, true, false)
}

// Log implements lg.Log, but directs its output to
// the logging functions of testing.T.
type Log struct {
	t      testing.TB
	strict bool
	impl   lg.Log
	buf    bytes.Buffer
	mu     sync.Mutex
}

// New returns a log that pipes output to t.
func New(t testing.TB) *Log {
	return NewWith(t, FactoryFn)
}

// NewWith returns a Log that pipes output to t, using
// the backing lg.Log instances returned by factoryFn
// to generate log messages.
func NewWith(t testing.TB, factoryFn func(io.Writer) lg.Log) *Log {
	tl := &Log{t: t}
	tl.impl = factoryFn(&tl.buf)
	return tl
}

// Strict sets strict mode. When in strict mode, Errorf logs
// via t.Error instead of t.Log, thus resulting in test failure.
func (tl *Log) Strict(strict bool) *Log {
	tl.strict = strict
	return tl
}

// Debugf logs at DEBUG level to t.Log.
func (tl *Log) Debugf(format string, v ...interface{}) {
	tl.mu.Lock()
	defer tl.mu.Unlock()

	tl.impl.Debugf(format, v...)
	output, _ := ioutil.ReadAll(&tl.buf)

	tl.t.Helper()
	tl.t.Log(stripNewLineEnding(string(output)))
}

// Warnf logs at WARN level to t.Log.
func (tl *Log) Warnf(format string, v ...interface{}) {
	tl.mu.Lock()
	defer tl.mu.Unlock()

	tl.impl.Warnf(format, v...)
	output, _ := ioutil.ReadAll(&tl.buf)

	tl.t.Helper()
	tl.t.Log(stripNewLineEnding(string(output)))
}

// Errorf logs at ERROR level to t.Log, or if in strict mode,
// the message is logged via t.Error, resulting in test failure.
func (tl *Log) Errorf(format string, v ...interface{}) {
	tl.mu.Lock()
	defer tl.mu.Unlock()

	tl.impl.Errorf(format, v...)
	output, _ := ioutil.ReadAll(&tl.buf)

	tl.t.Helper()

	if tl.strict {
		tl.t.Error(stripNewLineEnding(string(output)))
	} else {
		tl.t.Log(stripNewLineEnding(string(output)))

	}
}

// WarnIfError is no-op if err is nil; if non-nil, err
// is logged at WARN level.
func (tl *Log) WarnIfError(err error) {
	if err == nil {
		return
	}

	tl.mu.Lock()
	defer tl.mu.Unlock()

	tl.impl.Warnf(err.Error())
	output, _ := ioutil.ReadAll(&tl.buf)

	tl.t.Helper()
	tl.t.Log(stripNewLineEnding(string(output)))
}

// WarnIfFnError is no-op if fn is nil; if fn is non-nil,
// fn is executed and if fn's error is non-nil, that error
// is logged at WARN level.
func (tl *Log) WarnIfFnError(fn func() error) {
	if fn == nil {
		return
	}

	err := fn()
	if err == nil {
		return
	}

	tl.mu.Lock()
	defer tl.mu.Unlock()

	tl.impl.Warnf(err.Error())
	output, _ := ioutil.ReadAll(&tl.buf)

	tl.t.Helper()
	tl.t.Log(stripNewLineEnding(string(output)))
}

// stripNewLineEnding strips the trailing newline from
// the output generated by Log impls (which typically add
// a newline).
func stripNewLineEnding(s string) string {
	if strings.HasSuffix(s, "\n") {
		s = s[0 : len(s)-1]
	}
	return s
}
